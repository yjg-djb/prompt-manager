# Vibe Coding Prompt Templates (10)

> 用法建议：
> - 在 Cursor/Claude/Copilot 的聊天框里，复制某个模板的内容作为“指令主体”
> - 把 {{...}} 变量替换成你的真实信息（或直接粘贴需求/日志/文件路径）
> - 模板默认要求“先计划后动手 + 输出可验收结构”

---

## 目录
- 01 新功能实现（Feature Implementation）
- 02 修 Bug（Bugfix）
- 03 重构（Refactor）
- 04 补测试（Add Tests）
- 05 PR Review（代码评审）
- 06 性能优化（Performance）
- 07 安全加固（Security Hardening）
- 08 依赖升级（Dependency Upgrade）
- 09 API 设计与落地（API Design）
- 10 文档 & ADR（Docs + ADR）

---

## 01 新功能实现（Feature Implementation）

> 目标：把需求落到“可合并的 PR 级别代码”（含测试/文档/迁移说明）。

### 输入变量
- 需求描述：{{requirement}}
- 验收标准：{{acceptance_criteria}}
- 技术栈/框架：{{stack}}
- 约束（性能/兼容/安全/合规）：{{constraints}}
- 相关文件/模块（若已知）：{{related_paths}}
- 不可改动范围：{{do_not_touch}}

### 工作流程
1. 定位与理解：找到入口/数据流/边界（路由/handler/service/component），总结现状与副作用点（缓存/鉴权/幂等/并发）。
2. 计划（先写计划再动手）：给出最小变更方案（MVP），列出文件级变更清单；标出风险点与防护（测试/回滚点/feature flag）。
3. 实现：按项目现有架构落代码；非必要不改格式化/无关文件；避免顺手重构。
4. 测试：至少覆盖成功路径 + 1 个失败/边界路径；接口优先契约/集成测试；UI 加组件/交互测试。
5. 文档与可运维：更新 README/配置/用法；如有迁移写 migration notes（含回滚策略）。
6. 自检：lint/format、类型检查、单测、构建全部通过；逐条对照 constraints。

### 输出格式（必须严格按此输出）
- ✅ 一句话总结：完成了什么
- 🧭 变更范围：修改/新增文件清单
- 🧩 关键实现说明：3–7 条要点
- 🧪 测试：新增/更新测试 + 如何运行
- ⚠️ 风险与回滚：风险点 + 回滚方式
- 📌 未解决项：TODO（若有）

---

## 02 修 Bug（Bugfix）

> 目标：复现、定位根因、修复并加回归测试。

### 输入变量
- 现象/报错：{{symptom}}
- 期望行为：{{expected}}
- 复现步骤（若有）：{{repro_steps}}
- 影响范围/严重度：{{severity}}
- 相关日志/截图/trace：{{evidence}}
- 环境信息：{{env}}
- 不可改动范围：{{do_not_touch}}

### 工作流程
1. 问题定义：一句话写清“什么输入 -> 触发什么错误 -> 造成什么影响”。
2. 复现与缩小：找到最小复现（最小输入/最短路径）。
3. 根因分析（必须写出来）：指出具体代码位置 + 为什么会错（边界/并发/时序/空值/精度等）。
4. 修复方案：优先最小修复，避免扩大改动面。
5. 回归测试：新增 1 个精准回归测试（修复前失败，修复后通过）。
6. 风险评估：兼容性/一致性/性能影响；必要时加日志/指标。

### 输出格式
- 🐛 Bug 定义：输入/现象/期望
- 🔎 根因：文件/位置 + 行为解释
- 🛠️ 修复：改了什么、为什么这么改
- 🧪 回归测试：新增测试点 + 运行方式
- ⚠️ 风险：可能副作用 + 缓解方式

---

## 03 重构（Refactor）

> 目标：不改变外部行为，提升可读性/可维护性/可测试性。

### 输入变量
- 重构目标：{{refactor_goal}}
- 约束：{{constraints}}
- 相关模块/文件：{{related_paths}}
- 不可改动范围：{{do_not_touch}}

### 工作流程
1. 行为锁定：列出现有行为（含边界）；必要时先补测试锁死行为。
2. 重构计划：拆分成小步提交；每一步可编译、可运行、可回滚。
3. 执行：提取函数/模块、去重复、明确边界与依赖方向。
4. 验证：测试全绿；必要时做简单对比（日志/基准）。
5. 收尾：清理 TODO、死代码、命名与注释一致。

### 输出格式
- 🎯 重构目标：一句话
- 🧱 拆分步骤：2–6 个小步
- 🧩 关键改动：要点说明
- ✅ 行为保持证明：哪些测试/对比证明未改变行为

---

## 04 补测试（Add Tests）

> 目标：为指定模块建立可靠的测试网（优先覆盖风险最高路径）。

### 输入变量
- 被测对象/模块：{{target}}
- 当前风险：{{risk}}
- 测试类型偏好（单测/集成/E2E）：{{test_type}}
- 运行命令（若已知）：{{test_command}}

### 工作流程
1. 选择策略：单测（快/隔离）、集成（真实依赖）、E2E（关键用户路径）。
2. 用例设计：成功路径、失败路径、边界条件（空/极值/超时/权限）。
3. 实现：复用项目现有 fixtures/mocks/helpers 与约定。
4. 稳定性：避免脆弱断言（时间/随机/顺序）；必要时假时钟/固定种子。
5. 报告：覆盖了哪些风险点、还缺什么。

### 输出格式
- 🧪 新增测试文件：清单
- 📋 用例列表：用例 -> 断言点
- ▶️ 运行方式：命令 + 注意事项
- 🧯 稳定性说明：如何避免 flaky

---

## 05 PR Review（代码评审）

> 目标：抓大放小，指出风险与改进建议，并给出可执行修改。

### 输入变量
- PR 目标：{{pr_goal}}
- 变更 diff/文件：{{diff_or_files}}
- 重点关注：{{focus}}

### Review 维度（按优先级）
1. 正确性（边界/并发/幂等/错误处理/回滚）
2. 架构一致性（分层/依赖方向）
3. 可维护性（命名/复杂度/重复/可读性）
4. 测试（关键路径/失败路径）
5. 性能（N+1/缓存/热点）
6. 安全（输入校验/鉴权/注入/敏感信息）
7. DX（日志/可观测/文档）

### 输出格式
- ✅ 总体结论：Approve / Approve with nits / Request changes
- 🧨 必须修改（Blocking）：逐条（含原因 + 建议）
- 🧹 建议修改（Non-blocking）：逐条
- 🧪 测试建议：缺口与新增点
- 📌 可选优化：若有

---

## 06 性能优化（Performance）

> 目标：找到瓶颈、量化、再优化；避免“感觉优化”。

### 输入变量
- 性能问题：{{perf_problem}}
- 指标目标（p95/吞吐/内存/包体）：{{metric_goal}}
- 约束：{{constraints}}
- 相关路径/模块：{{related_paths}}

### 工作流程
1. 基线：给出当前可测基线（日志/Profiler/计时点/简单压测）。
2. 瓶颈定位：热点函数、IO、锁竞争、过量渲染、重复请求、N+1。
3. 优化方案：先低风险（缓存/批处理/剪枝/惰性加载），再结构性（算法/数据结构/并发模型）。
4. 验证：输出优化前后对比（数字/日志摘要）。
5. 回退：可快速回滚（开关/小提交粒度）。

### 输出格式
- 📉 基线：当前数据
- 🔥 瓶颈：定位证据
- 🛠️ 优化：做了什么
- 📈 结果：前后对比
- ⚠️ 风险：副作用与回退方式

---

## 07 安全加固（Security Hardening）

> 目标：补齐输入校验、鉴权、敏感信息处理与安全默认值。

### 输入变量
- 目标模块/接口：{{target}}
- 威胁模型/关注点：{{threats}}
- 约束（合规/兼容）：{{constraints}}

### 工作流程
1. 资产与边界：输入来源、信任边界、敏感数据流向。
2. 风险扫描：注入、XSS、CSRF、SSRF、路径穿越、权限绕过、IDOR、信息泄露等。
3. 加固实现：校验/净化、最小权限、统一鉴权、输出编码、超时/重试策略。
4. 安全测试：至少 1 个恶意输入用例 + 1 个权限边界用例。
5. 文档：安全注意事项、默认配置说明。

### 输出格式
- 🧯 风险点清单：逐条
- 🔐 加固改动：对应风险点的改动
- 🧪 安全用例：新增测试与运行方式
- 📌 余留风险：后续建议

---

## 08 依赖升级（Dependency Upgrade）

> 目标：安全、可回滚地升级依赖（含破坏性变更处理）。

### 输入变量
- 目标依赖/版本范围：{{dependency_and_target_version}}
- 升级原因（安全/功能/兼容）：{{reason}}
- 约束：{{constraints}}

### 工作流程
1. 影响评估：梳理 breaking changes（迁移指南/变更日志）。
2. 升级策略：小步升级；每步都能通过测试与构建。
3. 迁移修改：按迁移建议逐条落地（API/配置/构建脚本）。
4. 验证：单测/集成/构建；关键路径冒烟。
5. 回滚：记录回滚方式（锁版本/恢复 lockfile/撤销迁移）。

### 输出格式
- 📦 升级清单：依赖与版本
- 🧩 迁移要点：适配点
- ✅ 验证：运行了哪些命令/用例
- ⚠️ 风险与回滚：怎么退回

---

## 09 API 设计与落地（API Design）

> 目标：清晰、可演进的接口（含错误模型、鉴权与兼容策略）。

### 输入变量
- API 需求：{{api_requirement}}
- 协议类型（REST/GraphQL/gRPC/内部函数）：{{protocol}}
- 消费方：{{consumers}}
- 约束：{{constraints}}

### 设计要求
- 资源/动作建模清晰（命名一致）
- 版本/兼容策略（字段可选、默认值、弃用周期）
- 统一错误模型（错误码/可读消息/可定位信息）
- 鉴权与审计（权限点、记录项）
- 幂等与重试（必要时 idempotency key）

### 输出格式
- 📐 API 草案：请求/响应示例（含字段说明）
- ❗ 错误模型：错误码表（至少 5 个常见错误）
- 🔐 权限：鉴权点说明
- 🧪 测试：契约/集成测试建议
- 🧭 演进策略：版本/弃用计划

---

## 10 文档 & ADR（Docs + ADR）

> 目标：把关键决策和用法写清楚，减少口口相传。

### 输入变量
- 需要记录的决策/变更：{{decision_or_change}}
- 背景与问题：{{context}}
- 可选方案：{{options}}
- 约束：{{constraints}}

### ADR 结构
1. Title：一句话
2. Status：Proposed / Accepted / Deprecated
3. Context：为什么要做
4. Decision：做了什么决定
5. Consequences：代价与收益
6. Alternatives：为什么没选其他

### 输出格式
- 📄 文档变更：修改/新增文件清单
- 🧠 ADR：按结构输出
- 🔗 关联点：关联代码/配置/模块路径
